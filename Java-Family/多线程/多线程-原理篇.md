## 重排序

为了提高性能，编译器和处理器常常会对指令做重排。

```java
a = b + c;
d = e - f ;
```

先加载b、c（**注意，即有可能先加载b，也有可能先加载c**），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是**增加了停顿**，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。

指令重排对于**提高CPU处理性能十分必要**。虽然由此带来了乱序的问题，但是这点牺牲是值得的。一般分为以下三种：

- **编译器优化重排**

  编译器在**不改变单线程程序语义**的前提下，可以重新安排语句的执行顺序。

- **指令并行重排**

  现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。

- **内存系统重排**

  由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。

**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题。

## happends-before

对编译器和处理器来说，**只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。**

JMM提供了**happens-before规则**（JSR-133规范），满足了程序员的需求——**简单易懂，并且提供了足够强的内存可见性保证。**

happens-before关系的定义：

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，**并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行**。如果**重排序之后的执行结果**，与按happens-before关系来执行的结果一致，那么**JMM也允许这样的重排序**。

## volatile

在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：

- 保证变量的**内存可见性**
- 禁止volatile变量与普通变量**重排序**

### 内存可见性

```java
public class VolatileExample {
    int a = 0;
    volatile boolean flag = false;

    public void writer() {
        a = 1; // step 1
        flag = true; // step 2
    }

    public void reader() {
        if (flag) { // step 3
            System.out.println(a); // step 4
        }
    }
}
```

当一个线程对`volatile`修饰的变量进行**写操作**（比如step 2）时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对`volatile`修饰的变量进行**读操作**（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。

### 禁止重排序

如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。

为了提供一种比锁更轻量级的**线程间的通信机制**，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。

它是通过**内存屏障**来实现的。硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：

- 阻止屏障两侧的指令重排序
- 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者**让缓存中相应的数据失效**。

编译器在**生成字节码时**，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

- 在每个volatile写操作前插入一个StoreStore屏障；
- 在每个volatile写操作后插入一个StoreLoad屏障；
- 在每个volatile读操作后插入一个LoadLoad屏障；
- 在每个volatile读操作后再插入一个LoadStore屏障。

![image-20200522182720702](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522182720702.png)

### volatile的用途

在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个**临界区代码**的执行具有原子性。所以**在功能上，锁比volatile更强大；在性能上，volatile更有优势**。

```java
public class Singleton {

    private static Singleton instance; // 不使用volatile关键字

    // 双重锁检验
    public static Singleton getInstance() {
        if (instance == null) { // 第7行
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // 第10行
                }
            }
        }
        return instance;
    }
}
```

```java
// 如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：
instance = new Singleton(); // 第10行

// 可以分解为以下三个步骤
1 memory=allocate();// 分配内存 相当于c的malloc
2 ctorInstanc(memory) //初始化对象
3 s=memory //设置s指向刚分配的地址

// 上述三个步骤可能会被重排序为 1-3-2，也就是：
1 memory=allocate();// 分配内存 相当于c的malloc
3 s=memory //设置s指向刚分配的地址
2 ctorInstanc(memory) //初始化对象
```

而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候线程A执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！

### 总线风暴

总线风暴：**总线带宽达到峰值**；原因：

1. 内存屏障从**主内存嗅探**
2. **cas不断循环**无效交互导致

解决办法：
部分volatile和cas使用**synchronize**

## synchronized

**Java多线程的锁都是基于对象的**，Java中的每一个对象都可以作为一个锁。我们常听到的**类锁**其实也是对象锁。

在 Java 早期版本中，synchronized属于**重量级锁**，效率低下，因为**监视器锁**（monitor）是依赖于底层的操作系统的 **Mutex Lock** 来实现的，Java 的线程是**映射到操作系统的原生线程之上**的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换是**需要从用户态转换到内核态**，这个状态之间的转换需要相对比较长的时间，**时间成本相对较高**，这也是为什么早期的 synchronized 效率低的原因。

庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如**自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁**等技术来减少锁操作的开销。

在Java中，`synchronized`有两种使用形式，**同步方法**和**同步代码块**。

```java
public class SynchronizedTest {

    public synchronized void doSth(){
        System.out.println("Hello World");
    }

    public void doSth1(){
        synchronized (SynchronizedTest.class){
            System.out.println("Hello World");
        }
    }
}
```

通过`javap`反编译以上代码：

```java
public synchronized void doSth();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello World
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return

  public void doSth1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: ldc           #5                  // class com/hollis/SynchronizedTest
         2: dup
         3: astore_1
         4: monitorenter
         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         8: ldc           #3                  // String Hello World
        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        13: aload_1
        14: monitorexit
        15: goto          23
        18: astore_2
        19: aload_1
        20: monitorexit
        21: aload_2
        22: athrow
        23: return
```

对于同步方法，JVM采用**ACC_SYNCHRONIZED**标记符来实现同步。 对于同步代码块。JVM采用**monitorenter**、**monitorexit**两个指令来实现同步。

### 同步方法

方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有`ACC_SYNCHRONIZED`，如果有设置，则**需要先获得监视器锁**，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会**因为无法获得监视器锁而被阻断住**。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被**自动释放**。

### 同步代码块

可以把执行`monitorenter`指令理解为加锁，执行`monitorexit`理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行`monitorenter`）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，**计数器自增**。当同一个线程释放锁（执行`monitorexit`指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁（即**可重入锁**）。

### 类锁与对象锁

当synchronized加在静态方法，或者`synchronized(A.class)`时，锁信息是放在**class对象**中，俗称类锁。其他的方式加锁是把锁信息存放到**实例对象**中，俗称**对象锁**。但其实两者的本质是相同的，都是对象锁。在加载class时，首先会在堆上创建一个class对象，当创建实例对象时，是基于class对象创建实例对象的，并且静态变量、静态方法指向的是class对象。class对象对于一个class有且仅有一个。

## 锁分类

Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“**偏向锁**”和“**轻量级锁**“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

几种锁会随着竞争情况逐渐升级，**锁的升级很容易发生**，但是**锁降级发生的条件会比较苛刻**，锁降级发生在**Stop The World**期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。

每个Java对象都有对象头，锁的信息存放在对象头中。具体内容如下：

| 锁状态   | 29 bit 或 61 bit                 | 1 bit 是否是偏向锁？       | 2 bit 锁标志位 |
| :------- | -------------------------------- | -------------------------- | -------------- |
| 无锁     |                                  | 0                          | 01             |
| 偏向锁   | **线程ID**                       | 1                          | 01             |
| 轻量级锁 | **指向栈中锁记录的指针**         | 此时这一位不用于标识偏向锁 | 00             |
| 重量级锁 | **指向互斥量（重量级锁）的指针** | 此时这一位不用于标识偏向锁 | 10             |

### 锁底层存储

synchronized 对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：**对象头**（Header）、**实例数据**（Instance Data）和**对齐填充**（Padding）。

**对象头**：我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：**Mark Word**（标记字段）、Klass Pointer（类型指针）。

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200525141132.webp)

当 Monitor 被某个线程持有后，就会处于锁定状态，如图中的 Owner 部分，会指向持有 Monitor 对象的线程。

另外 Monitor 中还有两个队列分别是**EntryList和WaitList**，主要是用来存放进入及等待获取锁的线程。

如果线程进入，则得到当前对象锁，那么别的线程在该类所有对象上的任何操作都不能进行。

- **Mark Word**：默认存储对象的**HashCode，分代年龄和锁标志位**信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
- **Klass Point**：对象指向它的类元数据的指针（方法区），虚拟机通过这个指针来确定这个对象是哪个类的实例。


### 偏向锁

在大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，于是引入了偏向锁。**偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能**。

#### 实现原理

一个线程在第一次进入同步块的时候，会在对象头中记录偏向锁对应的线程ID。当下次另一个线程访问时，会先判断是不是自己的线程ID。

- 如果是。说明当前线程已经获取到了锁。
- 如果不是。说明需要进行锁竞争了，会尝试使用CAS替换线程ID。
  - 成功。说明之前的线程已经不存在了，更新线程ID，锁不会升级。
  - 失败。则暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为**轻量级锁**，会按照轻量级锁的方式进行锁竞争。
  
  ![image-20200522182853092](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522182853092.png)

偏向锁使用了一种**等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。

偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：

1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。 

如果程序中锁竞争比较厉害，那么可以把偏向锁关闭。`-XX:UseBiasedLocking=false`

### 轻量级锁

多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。JVM采用轻量级锁来避免线程的**阻塞与唤醒**。

当处于偏向锁时，先使用CAS尝试修改线程ID，如果修改失败，则将锁升级为轻量级锁，这时采用自旋的方式竞争锁。如果自旋失败，则将锁升级为重量级锁。

自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直消耗CPU资源。JVM采用**适应性自旋**的方式，线程如果**自旋成功**了，则下次自旋的次数会更多，如果**自旋失败**了，则自旋的次数就会减少。默认会自旋**30-50**次。

![image-20200522182948968](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522182948968.png)

### 重量级锁

重量级锁依赖于操作系统的**互斥量**（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁**效率很低**，但被阻塞的线程**不会消耗CPU**。

当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个`ObjectWaiter`对象插入到Contention List的队列的队首，然后调用`park`函数挂起当前线程。

当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做`Heir presumptive`即假定继承人，假定继承人被唤醒后会尝试获得锁，但`synchronized`是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，**线程先自旋尝试获得锁**，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。

如果线程获得锁后调用`Object.wait`方法，则会将线程加入到WaitSet中，当被`Object.notify`唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的`wait`或`notify`方法时，**如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁**。

### 锁比较

| 锁       | 优点                                                   | 缺点                                      | 适用场景                           |
| -------- | ------------------------------------------------------ | ----------------------------------------- | ---------------------------------- |
| 偏向锁   | 没有额外的开销，与没有锁的性能基本上没有差别           | 如果锁竞争比较厉害，则会带来更多的开销    | 锁基本无竞争                       |
| 轻量级锁 | 竞争锁的线程不会阻塞，避免了加锁的开销，以及上下文切换 | 自旋会消耗CPU，如果自旋失败还是要加锁操作 | 短时间内可以获取到锁，追求响应时间 |
| 重量级锁 | 不会消耗CPU                                            | 线程阻塞，影响性能                        | 追求吞吐量，锁竞争激烈             |

## 常见问题

### synchronized 和 ReentrantLock 的区别

**① 两者都是可重入锁**

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

**② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**

synchronized 是依赖于 JVM 实现的，前面我们也讲到了虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

**③ ReentrantLock 比 synchronized 增加了一些高级功能**

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）**

- **ReentrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。

如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。

**④ 性能已不是选择标准**

### synchronized 和 volatile 的区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在：

- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。但是**volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。
- **多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞**
- **volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。**
- **volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。**

## 乐观锁与悲观锁

- **悲观锁**

  悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证同一时间只能有一个线程在执行。

- **乐观锁**

  乐观锁又称`无锁`，它是乐观派，总是认为不会产生锁竞争。而一旦发生锁竞争，则通过`CAS`保证线程安全。因为不存在加锁，所以乐观锁天生**免疫死锁**。

乐观锁多用于“**读多写少**“的环境，避免频繁加锁影响性能；而悲观锁多用于”**写多读少**“的环境，避免频繁失败和重试影响性能。

## CAS

CAS的全称是：比较并交换（**Compare And Swap**）。在CAS中，有这样三个值：

- V：要更新的变量(var)
- E：预期值(expected)
- N：新值(new)

先判断要更新的变量是否与E（旧值）相同，如果相同则更新为N，如果不相同则失败返回。CAS是一种原子性操作，是native方法，通过CPU原子执行保障原子性。

当多个线程同时CAS操作时，则只会有一个线程成功，其他的都会失败，但是线程并不会挂起，只是告知失败，允许再次尝试更新，也可以直接返回。

### 实现原理（AtomicInteger）

在Java中，有一个`Unsafe`类，它在`sun.misc`包中。Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。它里面是一些`native`方法，其中就有几个关于CAS的：

```java
// 都是public native
boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);
boolean compareAndSwapInt(Object o, long offset,int expected,int x);
boolean compareAndSwapLong(Object o, long offset,long expected,long x);
```

DK提供了一些用于原子操作的类，在`java.util.concurrent.atomic`包下面。

![image-20200522183007703](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522183007703.png)

```java
// 定义Unsafe类
private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();

// 调用Unsafe类进行cas操作
public final int getAndAdd(int delta) {
    return U.getAndAddInt(this, VALUE, delta);
}
```

```java
// Unsafe类的getAndAddInt方法
@HotSpotIntrinsicCandidate
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    // 使用do-while，是保证循环体内的语句至少会被执行一遍
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}

public final boolean weakCompareAndSetInt(Object o, long offset,
                                          int expected,
                                          int x) {
    return compareAndSetInt(o, offset, expected, x);
}

public final native boolean compareAndSetInt(Object o, long offset,
                                             int expected,
                                             int x);
```

`weakCompareAndSet`操作仅保留了`volatile`自身变量的特性，而基于happends-before规则，`weakCompareAndSet`**无法保证处理操作目标的volatile变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。**这在一定程度上可以提高性能。

### 三大问题

#### ABA问题

一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。

ABA问题的解决思路是在变量前面追加上**版本号或者时间戳**。从JDK 1.5开始，JDK的atomic包里提供了一个类`AtomicStampedReference`类来解决ABA问题。

这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。

#### 循环时间长开销大

CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。

解决思路是让JVM支持处理器提供的**pause指令**。pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋。

#### 只能保证一个变量的原子操作

- 使用AtomicReference保证对象的原子性，把多个变量放到一个对象中操作
- 使用锁。同步块的代码可以保证同时只能有一个线程操作。

### LongAdder性能⽐AtomicLong要好

> 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。

去查阅了一些博客和资料，大概的意思就是：

- 使用AtomicLong时，在高并发下大量线程会同时去竞争更新**同一个原子变量**，但是由于同时只有一个线程的CAS会成功，所以其他线程会不断尝试自旋尝试CAS操作，这会浪费不少的CPU资源。
- 而LongAdder可以概括成这样：内部核心数据value**分离**成一个数组(Cell)，每个线程访问时,通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的**求和累加**。
  - 简单来说就是将一个值分散成多个值，在并发的时候就可以**分散压力**，性能有所提高。

参考资料：

- AtomicLong与LongAdder性能对比https://zhuanlan.zhihu.com/p/45489739
- LongAdder源码详解https://zhuanlan.zhihu.com/p/38288416

## AQS（ReentrantLock）

**AQS**是`AbstractQueuedSynchronizer`的简称，即`抽象队列同步器`，从字面意思上理解:

- 抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；
- 队列：使用先进先出（FIFO）队列存储数据；
- 同步：实现了同步的功能。

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。

### 数据结构

AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改版state的protected方法。

```java
getState()
setState()
// 依赖于Unsafe的compareAndSwapInt()方法
compareAndSetState()
```

AQS类本身实现的是一些**排队和阻塞**的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。内部使用了一个先进先出（FIFO）的双端队列。

![image-20200522183039872](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522183039872.png)

### 资源共享模式

资源有两种共享模式，或者说两种同步方式：

- 独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。
- 共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。

一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如`ReadWriteLock`。

```java
static final class Node {
    // 标记一个节点（对应的线程）在共享模式下等待
    static final Node SHARED = new Node();
    // 标记一个节点（对应的线程）在独占模式下等待
    static final Node EXCLUSIVE = null; 

    // waitStatus的值，表示该节点（对应的线程）已被取消
    static final int CANCELLED = 1; 
    // waitStatus的值，表示后继节点（对应的线程）需要被唤醒
    static final int SIGNAL = -1;
    // waitStatus的值，表示该节点（对应的线程）在等待某一条件
    static final int CONDITION = -2;
    /*waitStatus的值，表示有资源可用，新head节点需要继续唤醒后继节点（共享模式下，多线程并发释放资源，而head唤醒其后继节点后，需要把多出来的资源留给后面的节点；设置新的head节点时，会继续唤醒其后继节点）*/
    static final int PROPAGATE = -3;

    // 等待状态，取值范围，-3，-2，-1，0，1
    volatile int waitStatus;
    volatile Node prev; // 前驱节点
    volatile Node next; // 后继节点
    volatile Thread thread; // 节点对应的线程
    Node nextWaiter; // 等待队列里下一个等待条件的节点


    // 判断共享模式的方法
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    // 其它方法忽略，可以参考具体的源码
}

// AQS里面的addWaiter私有方法
private Node addWaiter(Node mode) {
    // 使用了Node的这个构造函数
    Node node = new Node(Thread.currentThread(), mode);
    // 其它代码省略
}
```

> 注意：通过Node我们可以实现两个队列，
>
> - 通过prev和next实现CLH队列(双向队列)
> - nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。

### ReentrantLock相较于Synchronized区别

- ReentrantLock可设置超时时间
- ReentrantLock可设置多个Condition（已经获取锁的线程还需要满足某些条件才能继续执行，这时会释放锁进入wait）
- ReentrantLock可以获取正在等待线程的个数、计数器等
- 可以设置公平锁与非公平锁

### ReentrantLock与CountDownLatch实现原理

以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

**CyclicBarrier(循环栅栏)：** CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

### 总结

- **AQS是**ReentrantReadWriteLock和ReentrantLock的**基础**，因为默认的实现都是在内部类Syn中，⽽Syn是继承AQS的~
- ReentrantReadWriteLock和ReentrantLock**都⽀持公平和⾮公平模式**，**公平模式下会去看FIFO队列线程是否是在队头**，⽽⾮公平模式下是没有的
- ReentrantReadWriteLock是⼀个读写锁，如果读的线程⽐写的线程要多很多的话，那可以考虑使⽤它。它使⽤state的变量**⾼16位是读锁，低16位是写锁**
- **写锁可以降级为读锁，读锁不能升级为写锁**
- **写锁是互斥的，读锁是共享的**。

### 源码

AQS的设计是基于**模板方法模式**的，它有一些方法必须要子类去实现的，它们主要有：

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false。

这些方法虽然都是`protected`方法，但是它们并没有在AQS具体实现，而是直接抛出异常。

#### 获取锁

![image-20200522183056113](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522183056113.png)

```java
// arg是要获取的资源的个数，在独占模式下始终为1。
public final void acquire(int arg) {
    // 尝试获取锁
    if (!tryAcquire(arg) &&
        // 获取不到锁，则进入等待队列，返回是否中断
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        // 如果返回中断，则调用当前线程的interrupt()方法
        selfInterrupt();
}
```

#### 尝试获取锁

tryAcquire(int)在ReentrantLock下的实现：

```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    //volatile读，确保了锁状态位的内存可见性
    int c = getState();
    //锁还没有被其他线程占用
    if (c == 0) {
        //此时，如果多个线程同时进入，CAS操作会确保，只有一个线程修改成功
        if (compareAndSetState(0, acquires)) {
            //设置当前线程拥有独占访问权
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //当前线程就是拥有独占访问权的线程，即锁重入
    else if (current == getExclusiveOwnerThread()) {
        //重入锁计数+1
        int nextc = c + acquires;
        if (nextc < 0) //溢出
            throw new Error("Maximum lock count exceeded");
        //只有获取锁的线程，才能进入此段代码，因此只需要一个volatile写操作，确保其内存可见性即可
        setState(nextc);
        return true;
    }
    return false;
}
```

#### 加入到等待队列中

```java
private Node addWaiter(Node mode) {
    //线程对应的Node
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    //尾节点不为空
    if (pred != null) {
        //当前node的前驱指向尾节点
        node.prev = pred;
        //将当前node设置为新的尾节点
        //如果cas操作失败，说明线程竞争
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //lockfree的方式插入队尾
    enq(node);
    return node;
}
private Node enq(final Node node) {
    //经典的lockfree算法：循环+CAS
    for (;;) {
        Node t = tail;
        //尾节点为空
        if (t == null) { // Must initialize
            //初始化头节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

#### 由自旋到阻塞

入队后，调用acquireQueued方法，时而自旋，时而阻塞，直到获取锁（或被取消）。**根据前一个节点是否是head判断是否需要自旋，否则则阻塞**。

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            //其前驱是头节点，并且再次调用tryAcquire成功获取锁
            if (p == head && tryAcquire(arg)) {
                //将自己设为头节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                //成功获取锁，返回
                return interrupted;
            }
            //没有得到锁时：
            //shouldParkAfterFailedAcquire方法：返回是否需要阻塞当前线程
            //parkAndCheckInterrupt方法：阻塞当前线程，当线程再次唤醒时，返回是否被中断
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                //修改中断标志位
                interrupted = true;
        }
    } finally {
        if (failed)
            //获取锁失败，则将此线程对应的node的waitStatus改为CANCEL
            cancelAcquire(node);
    }
}

private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}

/**
     * 获取锁失败时，检查并更新node的waitStatus。
     * 如果线程需要阻塞，返回true。
     */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;

    //前驱节点的waitStatus是SIGNAL。
    if (ws == Node.SIGNAL)
        /* 
             * SIGNAL状态的节点，释放锁后，会唤醒其后继节点。
             * 因此，此线程可以安全的阻塞（前驱节点释放锁时，会唤醒此线程)。
             */
        return true;

    //前驱节点对应的线程被取消
    if (ws > 0) {
        do {
            //跳过此前驱节点
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
               此时，需要将前驱节点的状态设置为SIGNAL。
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
//当shouldParkAfterFailedAcquire方法返回true，则调用parkAndCheckInterrupt方法阻塞当前线程
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
```

>LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：
>
>- park(boolean isAbsolute, long time)：阻塞当前线程
>- unpark(Thread jthread)：使给定的线程停止阻塞

#### 释放锁

```java
public final boolean release(int arg) {
    //修改锁计数器，如果计数器为0,说明锁被释放
    if (tryRelease(arg)) {
        Node h = head;
        //head节点的waitStatus不等于0，说明head节点的后继节点对应的线程，正在阻塞，等待被唤醒
        if (h != null && h.waitStatus != 0)
            //唤醒后继节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}

private void unparkSuccessor(Node node) {
    // 如果状态是负数，尝试把它设置为0
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);
    // 得到头节点的后继节点head.next
    Node s = node.next;
    // 如果这个后继节点为空或者状态大于0
    // 通过前面的定义我们知道，大于0只有一种可能，就是这个节点已被取消
    if (s == null || s.waitStatus > 0) {
        s = null;
        // 等待队列中所有还有用的节点，都向前移动
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    // 如果后继节点不为空，
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

## 读写锁

常用的synchronized和ReentrantLock都是**排它锁**，同一时刻只能有一个线程访问，而**读写锁**可以允许多个线程同时访问。内部维护了两把锁（读锁、写锁），通过分离读写锁，使得在**读多写少**的场景下提高性能。

### ReentrantReadWirteLock

这是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。

但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“**写饥饿**”

```java
// 内部结构
private final ReentrantReadWriteLock.ReadLock readerLock;
private final ReentrantReadWriteLock.WriteLock writerLock;
final Sync sync;
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 具体实现
}
static final class NonfairSync extends Sync {
    // 具体实现
}
static final class FairSync extends Sync {
    // 具体实现
}
public static class ReadLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected ReadLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
    }
    // 具体实现
}
public static class WriteLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
    }
    // 具体实现
}

// 构造方法，初始化两个锁
public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}

// 获取读锁和写锁的方法
public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
```

### StampedLock

`StampedLock`类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和`ReadWriteLock`接口，但它其实是实现了“读写锁”的功能，并且性能比`ReentrantReadWriteLock`更高。`StampedLock`还把读锁分为了“乐观读锁”和“悲观读锁”两种。

核心思想在于，**在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样**。

```java
// StampedLock的用法
class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();

   // 写锁的使用
   void move(double deltaX, double deltaY) {
     long stamp = sl.writeLock(); // 获取写锁
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp); // 释放写锁
     }
   }

   // 乐观读锁的使用
   double distanceFromOrigin() {
     long stamp = sl.tryOptimisticRead(); // 获取乐观读锁
     double currentX = x, currentY = y;
     if (!sl.validate(stamp)) { // //检查乐观读锁后是否有其他写锁发生，有则返回false
        stamp = sl.readLock(); // 获取一个悲观读锁
        try {
          currentX = x;
          currentY = y;
        } finally {
           sl.unlockRead(stamp); // 释放悲观读锁
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }

   // 悲观读锁以及读锁升级写锁的使用
   void moveIfAtOrigin(double newX, double newY) {
     long stamp = sl.readLock(); // 悲观读锁
     try {
       while (x == 0.0 && y == 0.0) {
         // 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用
         long ws = sl.tryConvertToWriteLock(stamp); 

         if (ws != 0L) { // 如果转换成功
           stamp = ws; // 读锁的票据更新为写锁的
           x = newX;
           y = newY;
           break;
         }
         else { // 如果转换失败
           sl.unlockRead(stamp); // 释放读锁
           stamp = sl.writeLock(); // 强制获取写锁
         }
       }
     } finally {
       sl.unlock(stamp); // 释放所有锁
     }
   }
}}
```

##  CopyOnWrite

CopyOnWrite容器即**写时复制的容器**，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。

**优点：**适用于**读多写少**场景，在读的时候不会加锁，大大提高读的性能。在写的时候加锁，又可以保证数据**最终一致性**。

**缺点：**占用内存比较大，可能会引起频繁GC。在写操作的过程中，读取到的数据可能是老数据，会有短暂的不一致。

```java
// CopyOnWriteArrayList的add方法
public boolean add(E e) {

    // ReentrantLock加锁，保证线程安全
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝原容器，长度为原容器长度加一
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 在新副本上执行添加操作
        newElements[len] = e;
        // 将原容器引用指向新副本
        setArray(newElements);
        return true;
    } finally {
        // 解锁
        lock.unlock();
    }
}
```

## 线程池

使用线程池的原因：

- 线程池可以**复用已创建的线程**
- **控制并发的数量**。
- **可以对线程做统一管理**。

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200611215229)

### 核心参数

- **int corePoolSize**：该线程池中**核心线程数最大值**

- **int maximumPoolSize**：该线程池中**线程总数最大值** 

  > 当核心线程数用完了以后并不会立即创建新的线程，而是等待队列满了以后，并且线程数小于最大线程数，才会创建新的线程。

- **long keepAliveTime**：**非核心线程闲置超时时长**。

- **TimeUnit unit**：keepAliveTime的单位。

- **BlockingQueue workQueue**：阻塞队列，维护着**等待执行的Runnable任务对象**。

  常用的几个阻塞队列：

  1. **LinkedBlockingQueue**

     链式阻塞队列，底层数据结构是链表，默认大小是`Integer.MAX_VALUE`，也可以指定大小。

  2. **ArrayBlockingQueue**

     数组阻塞队列，底层数据结构是数组，需要指定队列的大小。

  3. **SynchronousQueue**

     同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。

  4. **DelayQueue**

     延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。

- **ThreadFactory threadFactory**，创建线程的工厂类。不指定则使用默认工厂

- **RejectedExecutionHandler handler**

  **拒绝处理策略**，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：

  1. **ThreadPoolExecutor.AbortPolicy**：**默认拒绝处理策略**，丢弃任务并抛出RejectedExecutionException异常。
  2. **ThreadPoolExecutor.DiscardPolicy**：丢弃新来的任务，但是不抛出异常。
  3. **ThreadPoolExecutor.DiscardOldestPolicy**：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。
  4. **ThreadPoolExecutor.CallerRunsPolicy**：由调用线程处理该任务。

### 处理流程

1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 < corePoolSize时）。**注意，这一步需要获得全局锁。**

2. 线程总数量 >= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。 

3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**

4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。

   ![image-20200522183312515](https://520li.oss-cn-hangzhou.aliyuncs.com/img/image-20200522183312515.png)

### 线程池状态

线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。

故线程池也有自己的状态。`ThreadPoolExecutor`类中定义了一个`volatile int`变量**runState**来表示线程池的状态 ，分别为**RUNNING**、**SHURDOWN**、**STOP**、**TIDYING** 、**TERMINATED**。

- 线程池创建后处于**RUNNING**状态。

- 调用`shutdown()`方法后处于**SHUTDOWN**状态，线程池不能接受新的任务，清除一些**空闲**worker,会**等待阻塞队列**的任务完成。

- 调用`shutdownNow()`方法后处于**STOP**状态，线程池不能接受新的任务，**中断所有线程**，阻塞队列中没有被执行的任务**全部丢弃**。此时，poolsize=0,阻塞队列的size也为0。

- 当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为**TIDYING**状态。接着会执行terminated()函数。

  > ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量。

- 线程池处在TIDYING状态时，**执行完terminated()方法之后**，就会由 **TIDYING -> TERMINATED**， 线程池被设置为TERMINATED状态。

### 源码解析

```java
// JDK 1.8 
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();   
    int c = ctl.get();
    // 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务
    if (workerCountOf(c) < corePoolSize) {
       if (addWorker(command, true))
           return;
       c = ctl.get();
    }
    // 2.如果不小于corePoolSize，则将任务添加到workQueue队列。
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。
        if (! isRunning(recheck) && remove(command))
            reject(command);
            // 2.2 线程池处于running状态，但是没有线程，则创建线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3.如果放入workQueue失败，则创建非核心线程执行任务，
    // 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。
    else if (!addWorker(command, false))
         reject(command);
}
```

```java
// 创建线程，core标识是否是核心线程
private boolean addWorker(Runnable firstTask, boolean core) {
    // 判断线程数量是否超出阈值，超过了就返回false
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                // 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程
                // 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数
                // 如果不小于，则返回false
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
    // 创建worker对象，并初始化一个Thread对象，然后启动这个线程对象。
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 1.创建一个worker对象
        w = new Worker(firstTask);
        // 2.实例化一个Thread对象
        final Thread t = w.thread;
        if (t != null) {
            // 3.线程池全局锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 4.启动这个线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

```java
// Worker类部分源码，继承了AQS，实现了Runable接口
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;
    Runnable firstTask;

    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
            runWorker(this);
    }
    //其余代码略...
}
```

```java
//向线程池中添加线程成功，并且启动也成功，则执行Worker对象的run方法，进入runWorker方法逻辑
final void runWorker(ThreadPoolExecutor.Worker w) {
    Thread wt = Thread.currentThread();
    //在构造Worker对象的时候，会把一个任务添加进Worker对象
    //因此需要把其作为新增线程的第一个任务来执行
    Runnable task = w.firstTask;
    //已经将该任务拿出来进行执行，则需要将该worker对象即线程池中的线程对象
    //持有的任务清空
    w.firstTask = null;
    //将AQS锁资源的状态有-1变成0，运行该线程进行中断
    w.unlock();
    //用来判断执行任务的过程中，是否出现了异常
    boolean completedAbruptly = true;
    try {
        //线程池中的线程循环处理线程池中的任务，知道线程池中的任务被处理完
        //跳出循环
        while (task != null || (task = getTask()) != null) {
            //给该线程加锁，一个线程只处理一个任务
            w.lock();
            // 线程池是否是STOP状态
            // 如果是，则确保当前线程是中断状态
            // 如果不是，则确保当前线程不是 中断状态
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //扩展使用，在执行任务的run方法之前执行
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //执行任务的run方法
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //扩展使用，在执行任务的run方法之后执行
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        //正常执行完任务
        completedAbruptly = false;
    } finally {
        //所有的任务都处理完后，或者执行任务的过程中出现了异常
        processWorkerExit(w, completedAbruptly);
    }
}
```

```java
private Runnable getTask() {
    //timedOut表示 记录上一次从队列中获取任务是否超时
    boolean timedOut = false; // Did the last poll() time out?
    //自旋
    for (;;) {
        //获取线程池的状态和线程池中线程数量组成的整形字段，32位
        // 高3位代表线程池的状态，低29位代表线程池中线程的数量
        int c = ctl.get();
        //获取高3位的值，即线程池的状态
        int rs = runStateOf(c);

        // 如果线程状态不是Running状态，并且 线程也不是SHUTDOWN状态 或者任务队列已空
        //
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            //则将线程池中的线程数量减1
            decrementWorkerCount();
            //返回一个空任务，1：如果任务队列已空，则想返回任务也没有
            //             2:如果线程池处于STOP或者之上的状态，则线程池不允许在处理任务
            return null;
        }
        //获取低29位的值，即线程池中线程的数量
        int wc = workerCountOf(c);

        // timed是否需要进行超时控制
        // allowCoreThreadTimeOut默认false
        // 当线程池中线程的数量没有达到核心线程数量时，获取任务的时候不允许超时
        // 当线程池中线程的数量超过核心线程数量时，获取任务的时候不允许超时
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        // wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；
        // timed && timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时
        // 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；
        // 如果减1失败，则返回重试
        // 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            //获取任务
            //如果timed = true ，则根据keepAliveTime设置的时间内，阻塞等待从队列中获取任务
            //如果timed = false，则阻塞，直到从队列中获取到任务为止
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            workQueue.take();
            //如果获取到任务，则把任务返回
            if (r != null)
                return r;
            //执行到这里，说明在允许的时间内，没有获取到任务
            timedOut = true;
        } catch (InterruptedException retry) {
            //获取任务没有超时，但是出现异常了
            timedOut = false;
        }
    }
}
```

```java
private void processWorkerExit(ThreadPoolExecutor.Worker w, boolean completedAbruptly) {
    //如果 completedAbruptly = true ，则线程执行任务的时候出现了异常，需要从线程池中减少一个线程
    //如果 completedAbruptly = false，则执行getTask方法的时候已经减1，这里无需在进行减1操作
    if (completedAbruptly)
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        //统计该线程池完成的任务数
        completedTaskCount += w.completedTasks;
        //从线程池中移除一个工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }
    //根据线程池的状态，决定是否结束该线程池
    tryTerminate();

    int c = ctl.get();
    //当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；
    //如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；
    //如果allowCoreThreadTimeOut=false，活跃线程数不少于corePoolSize
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
```

### 常见问题

#### 参数设置的依据

根据任务的类型，可参考计算方法：

- CPU密集型。一般设置为CPU核数+1，可以充分利用CPU
- IO密集型。一般设置为CPU核数*2
- 混合型。一般设置为：（线程等待时间与线程CPU时间之比 + 1）* CPU数目，比如IO操作需要1S，CPU运行时间需要0.5S，8核的服务器，则为：（1 / 0.5 + 1） * 8 = 24

但以上计算方式**仅作为参考**，因为：

- 服务器上可能运行了多个服务，或多个线程池
- 任务的运行时间分布并不是一成不便，受多方面影响
- 线程池需要承载的任务会**存在峰谷**，在低峰时可以满足业务QPS的需求，但是在高峰时可能会撑满

解决办法：

- 采用动态线程池的方案，ThreadPoolExcutor支持动态更改参数：`public void setCorePoolSize(int corePoolSize)`和`public void setMaximumPoolSize(int maximumPoolSize)`

  > 可以参考美团的解决方案，采用动态配置中心，监控线程池运行状态，可灵活变更线程池参数。[ 参考 ](https://mp.weixin.qq.com/s/D73p4StaBA1sXEoZQZrEaQ)

- 可以采用MQ代替线程池，把任务分发到不同的服务器上，实现分布式。

#### 使用场景

- 一般结合Spring的@Async注解，加上线程池的参数配置，自动实现。
- 一般用于一些异步任务，如：登录记录、操作记录、慢接口记录、错误信息记录，异步生成头像、二维码等操作

#### 异常机制

如果任务内部抛出了异常，那么可以通过设置`afterExecute()`实现自定义的异常日志打印。如果抛出了异常，则会**销毁该work**（线程），然后创建一个新的work。详见`runWorker()`，`processWorkerExit()`的源码分析

#### 为什么worker要继承AQS

Worker继承AQS，使用AQS**实现独占锁，并且是不可重入的**。构造Worker对象的时候，会把锁资源状态设置成-1，因为新增的线程，还没有处理过任务，是不允许被中断的。

在任务执行时，会先加锁，如果是`shutdown()`时，会先获取到work的独占锁，也就是会等任务执行完成，如果是`shutdownNow()`时，直接去中断线程，不会等待任务执行完成。

#### 为什么不使用Executors

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/15406254121131.jpg)



## 通信工具类

| 类             | 作用                                       |
| -------------- | ------------------------------------------ |
| Semaphore      | 限制线程的数量                             |
| Exchanger      | 两个线程交换数据                           |
| CountDownLatch | 线程等待直到计数器减为0时开始工作          |
| CyclicBarrier  | 作用跟CountDownLatch类似，但是可以重复使用 |

### Semaphore

信号量，可以控制同时执行的线程数量。最主要的方法是acquire方法和release方法。

Semaphore内部有一个继承了AQS的同步器Sync，重写了`tryAcquireShared`方法。在这个方法里，会去尝试获取资源。

如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。

### Exchanger

Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在**两个线程**之间传送任何数据。

当一个线程调用exchange方法后，它是处于阻塞状态的，只有当另一个线程也调用了exchange方法，它才会继续向下执行。看源码可以发现它是使用**park/unpark**来实现等待状态的切换的，但是在使用park/unpark方法之前，使用了CAS检查，估计是为了提高性能。

```java
public class ExchangerDemo {
    public static void main(String[] args) throws InterruptedException {
        Exchanger<String> exchanger = new Exchanger<>();

        new Thread(() -> {
            try {
                System.out.println("这是线程A，得到了另一个线程的数据："
                        + exchanger.exchange("这是来自线程A的数据"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        System.out.println("这个时候线程A是阻塞的，在等待线程B的数据");
        Thread.sleep(1000);

        new Thread(() -> {
            try {
                System.out.println("这是线程B，得到了另一个线程的数据："
                        + exchanger.exchange("这是来自线程B的数据"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

### CountdownLatch

计数器，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。

CountDownLatch内部同样是一个基层了AQS的实现类Sync，且实现起来还很简单，可能是JDK里面AQS的子类中最简单的实现了。

需要注意的是构造器中的**计数值（count）实际上就是闭锁需要等待的线程数量**。这个值只能被设置一次，而且CountDownLatch**没有提供任何机制去重新设置这个计数值**。

```java
// 构造方法：
public CountDownLatch(int count)

public void await() // 等待，线程阻塞
public boolean await(long timeout, TimeUnit unit) // 超时等待
public void countDown() // count - 1
public long getCount() // 获取当前还有多少count
```

### CyclicBarrier

与`CountDownLatch`很相似，拥有`CountDownLatch`的所有功能，可以使用`reset()`方法重置。

如果在参与者（线程）在等待的过程中，Barrier被破坏，就会抛出BrokenBarrierException。可以用`isBroken()`方法检测Barrier是否被破坏。

CyclicBarrier没有分为`await()`和`countDown()`，而是只有单独的一个`await()`方法。

CyclicBarrier虽说功能与CountDownLatch类似，但是实现原理却完全不同，CyclicBarrier内部使用的是Lock + Condition实现的等待/通知模式。

```java
public class CyclicBarrierDemo {
    static class PreTaskThread implements Runnable {

        private String task;
        private CyclicBarrier cyclicBarrier;

        public PreTaskThread(String task, CyclicBarrier cyclicBarrier) {
            this.task = task;
            this.cyclicBarrier = cyclicBarrier;
        }

        @Override
        public void run() {
            // 假设总共三个关卡
            for (int i = 1; i < 4; i++) {
                try {
                    Random random = new Random();
                    Thread.sleep(random.nextInt(1000));
                    System.out.println(String.format("关卡%d的任务%s完成", i, task));
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                cyclicBarrier.reset(); // 重置屏障
            }
        }
    }

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -> {
            System.out.println("本关卡所有前置任务完成，开始游戏...");
        });

        new Thread(new PreTaskThread("加载地图数据", cyclicBarrier)).start();
        new Thread(new PreTaskThread("加载人物模型", cyclicBarrier)).start();
        new Thread(new PreTaskThread("加载背景音乐", cyclicBarrier)).start();
    }
}
// 关卡1的任务加载地图数据完成
// 关卡1的任务加载背景音乐完成
// 关卡1的任务加载人物模型完成
// 本关卡所有前置任务完成，开始游戏...
// 关卡2的任务加载地图数据完成
// 关卡2的任务加载背景音乐完成
// 关卡2的任务加载人物模型完成
// 本关卡所有前置任务完成，开始游戏...
// 关卡3的任务加载人物模型完成
// 关卡3的任务加载地图数据完成
// 关卡3的任务加载背景音乐完成
// 本关卡所有前置任务完成，开始游戏...
```

## Fork/Join

**fork**在英文里有分叉的意思，**join**在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。

体现**分而治之(divide and conquer)** 的算法思想。Fork/Join框架在执行任务时使用了**工作窃取算法**。

在Stream的并行操作时，底层使用的就是Fork/Join框架。

常用ForkJoinPool负责管理线程和任务，用ForkJoinTask的子类RecursiveTask 和RecursiveAction执行任务。

详细说明见：[参考](https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/18)

![image](https://520li.oss-cn-hangzhou.aliyuncs.com/img/fork_join流程图.png)
