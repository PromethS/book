# mysql大表

1. 架构
        分库、分表
2. 数据拆分
    分冷热数据
3. 数据类型
    日期类型，无符号整数，char与varchar，优先使用整数（浮点数或IP等特殊数据），默认值
4. 数据读
    事务隔离级别，索引设计，联合索引，减少回表（覆盖索引，索引下推）
5. 数据写
    事务，索引数量，批量写
6. sql优化
    type在range级别及以上，避免索引失效（like, or），in与exist，深度分页
7. 客户端
    连接池参数设置，乐观锁与悲观锁

# 发号器

1. ID的生成
        sequence，雪花算法（和时间强相关，考虑时钟回拨）
2. 持久化
    可以使用etcd、zk、mysql等保证持久性
3. 高可用
    etcd或zk的watch + ttl机制，检测到master宕机，slave提供服务（服务本身无状态，从持久库上同步状态）
4. 高性能
    区间缓存，一次批量申请（或时间），减少和etcd的交互
    客户端缓存，一次申请多个ID，减少网络开销
    多个master提供服务，需要考虑全局单调和并发问题，如sequence使用多个区间段，雪花算法使用机器ID
5. 权限隔离
    基于用户和业务进行隔离，确保互相无影响
6. 通信协议
    可以用grpc（但没有故障转移），可以使用redis cluster协议

[有赞发号器多机房方案](https://mp.weixin.qq.com/s/v7-5kMfEXG0zNhMDYpMzBg)

# 秒杀系统

1. 客户端
        动态秒杀url（秒杀前隐藏），活动校验，
    2. 网关
        恶意请求限制（根据IP地址，终端指纹信息），负载均衡（nginx或f5）
        
    3. 流量保护
        限流保护应用，独立部署隔离影响
        
    4. 高并发读

        详见专题： [热点库存.md](热点库存.md) 

        > 高并发写 引入redis维护库存值，扣减流程变为先扣减redis,然后插入log,我们如何保证redis和插入log同时成功呢？
        >
        > 解决方式：**不保证**。最坏的结果就是**redis的库存值小于真实的库存值，导致部分商品在热点扣减场景无法售卖**

    5. DB锁竞争厉害，排队处理，或使用写缓存（sql解析） + 写日志的方式（有赞秒杀的DB组件，解决高并发写问题）
        通过mq方式异步处理其他相关服务

    6. 超卖
        DB的乐观锁控制

    7. 扣库存
        下单扣库存，超时释放库存，可能会出现恶意下单不支付。如支付后扣库存，需要两阶段预占库存