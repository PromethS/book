## 关于LSM树

LSM树，即**日志结构合并树**(Log-Structured Merge-Tree)。其实它并不属于一个具体的数据结构，它更多是一种**数据结构的设计思想**。大多NoSQL数据库核心思想都是基于LSM来做的，只是具体的实现不同。

传统关系型数据库使用btree或一些变体作为存储结构，能高效进行查找。但保存在磁盘中时它也有一个明显的缺陷，那就是**逻辑上相离很近但物理却可能相隔很远**，这就可能造成大量的**磁盘随机读写**。随机读写比顺序读写慢很多，为了提升IO性能，我们需要一种能将随机操作**变为顺序操作的机制**，于是便有了LSM树。LSM树能让我们进行顺序写磁盘，从而**大幅提升写操作**，作为代价的是**牺牲了一些读性能**。

## 由来

假如对写操作的吞吐量比较敏感，可采用日志策略（**顺序读写，只追加不修改**）来提升写性能。存在问题：数据查找需要倒序扫描，花费很多时间。比如，预写日志WAL，WAL的中心概念是**数据文件（存储着表和索引）的修改必须在这些动作被日志记录之后才被写入，即在描述这些改变的日志记录被刷到持久存储以后**。如果我们遵循这种过程，我们不需要在每个事务提交时刷写数据页面到磁盘，因为我们知道在发生崩溃时可以使用日志来恢复数据库：任何还没有被应用到数据页面的改变可以根据其日志记录重做（这是前滚恢复，也被称为REDO）。使用WAL可以显著降低磁盘的写次数，因为**只有日志文件需要被刷出到磁盘以保证事务被提交，而被事务改变的每一个数据文件则不必被刷出**。

其只是**提高了写的性能**，对于**更为复杂的读性能，需要寻找其他的方法**，其中有四种方法来提升读性能：

1. 二分查找: 将文件数据有序保存，使用二分查找来完成特定key的查找。
2. 哈希：用哈希将数据分割为不同的bucket
3. B+树：使用B+树 或者 ISAM 等方法，可以减少外部文件的读取
4. 外部文件： 将数据保存为日志，并创建一个hash或者查找树映射相应的文件。

所有的四种方法都可以有效的提高了读操作的性能（最少提供了O(log(n)) )，但是，却**丢失了日志文件超好的写性能**，上面这些方法，都强加了总体的结构信息在数据上，数据被按照特定的方式放置，所以可以很快的找到特定的数据，但是却对写操作不友善，让写操作性能下降。更糟糕的是，当需要更新hash或者B+树的结构时，需要同时更新文件系统中特定的部分，这就是造成了比较慢的随机读写操作，这种随机的操作要尽量减少。

既要保证日志文件好的写性能，又要在一定程度上保证读性能，所以LSM-Tree应运而生。

下面块为引用https://www.cnblogs.com/yanghuahui/p/3483754.html，进行对比

讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚**LSM树的由来**：

- 哈希存储引擎  是哈希表的持久化实现，支持增、删、改以及随机读取操作，**但不支持顺序扫描**，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(logn)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right
- B树存储引擎是B树[（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）](http://www.cnblogs.com/yanghuahui/p/3483047.html)的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。
- LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。**当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。**

LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将**对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能）**，是一种基于硬盘的数据结构，与B-tree相比，能显著地**减少硬盘磁盘臂的开销。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。**

读取时需要**合并磁盘中的历史数据和内存中最近的修改操作,读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。但是磁盘中会定期做merge操作，合并成一棵大树，以优化读性能）。**LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。

代表数据库：nessDB、leveldb、**hbase**等

核心思想的核心就是**放弃部分读能力，换取写入的最大化能力，**放弃磁盘读性能来**换取写的顺序性**。极端的说，基于LSM树实现的**HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级**。MongoDB的WiredTiger引擎支持B树和LSM树两种结构，B树比LSM树的读性能上高1.5-2倍，但是写性能上差1.5-2倍。要根据业务场景判断是读多写少还是读少写多来选择。

## LSM操作

LSM树 **插入数据**可以看作是一个N阶合并树。数据写操作（包括插入、修改、删除也是写）都在内存中进行，同时**在日志文件中插入操作日志**，以便后面恢复使用，日志是以append形式插入，所以速度非常快。

数据首先会**插入内存中的树。当内存树的数据量超过设定阈值后，会进行合并操作**。合并操作会从左至右遍历内存中树的子节点 与 磁盘中树的子节点并进行合并，会用最新更新的数据覆盖旧的数据（或者记录为不同版本）。当被合并合并数据量达到磁盘的存储页大小时。会将合并后的数据持久化到磁盘，同时更新父节点对子节点的指针。

LSM树 **读数据** 磁盘中树的非子节点数据也被缓存到内存中。在需要进行读操作时，总是从内存中的**排序树**开始搜索，如果没有找到，就从磁盘上的排序树顺序查找。

在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于B+树。当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。

LSM树 **删除数据** 前面讲了。LSM树所有操作都是在内存中进行的，那么删除并不是物理删除。而是一个逻辑删除，会在被删除的数据上打上一个标签，当内存中的数据达到阈值的时候，会与内存中的其他数据一起顺序写入磁盘。 这种操作会占用一定空间，但是LSM-Tree 提供了一些机制回收这些空间。