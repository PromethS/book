# 引言
我们都知道二叉查找树的查找的时间复杂度是**Ｏ(log N)**，其查找效率已经足够高了，那为什么还有Ｂ树和Ｂ＋树的出现呢？难道它两的时间复杂度比二叉查找树还小吗？
答案当然不是，Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是**磁盘ＩＯ**；众所周知，ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。
所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是：

- **每个节点存储多个元素**
- **摒弃二叉树结构，采用多叉树**

　　这样就引出来了一个新的查找树结构 ——**多路查找树**。 根据AVL给我们的启发，一颗平衡多路查找树(B~树)自然可以使得数据的查找效率保证在**O(logN)**这样的对数级别上。

# B树

一颗m阶的B树（B-tree） 定义如下：

（1）**每个节点最多有 m-1 个key**；

（2）根节点至少有1个key；

（3）非根节点至少有 Math.ceil(m/2)-1 个key；

（4）每个节点中的key都按照**从小到大的顺序**排列，每个key的左子树中的所有key都小于它，而右子树中的所有key都大于它；

（5）**所有叶子节点都位于同一层**，即根节点到每个叶子节点的长度都相同。

  如下图是一棵4阶B树（2-3-4树），

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200527005128)

## 存储容量
  打个比方，以2-3树为例，树高为3的时候，一棵2-3树可以保存2+3x2+3x2x2=20个key，若当B树的阶数达到1001阶，即一个节点可以放1000个key，然后树高还是3，即 1000+1000x1001+1000x1001x1000 ，零头不算了，即至少可以放10个亿的key，此时我们只要让根节点读取到内存中，把子节点及子孙节点持久化到硬盘中，那么在这棵树上，寻找某一个key至多需要2次硬盘的读取即可。

## 插入

而对于B树节点的插入，可以类比2-3-4树，即，**若节点插入节点的key还未“丰满”，则直接插入，若节点插入节点的key已“丰满”，则插入节点之后分裂，再以分裂之后的父节点看作向上层插入的节点调整，直至满足该 m 阶的B树**。如下，为5阶B树插入节点的动态图，

> 注：5阶的非根节点至少有 Math.ceil(5/2)-1 个key，即，至少要有2个key，根节点可以为1个key

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200527005402)

## 删除  

对于B树节点的删除，也一样类比2-3-4树，如下，

1. **若删除非叶子节点**， 找后继节点替换之，将问题转化为删除叶子节点；
2. **若删除叶子节点**，且叶子节点的key数大于定义中的最小值（根节点至少有1个key，非根节点至少有 Math.ceil(m/2)-1 个key），则直接删除即可，无需调整，
3. 若删除叶子节点，且叶子节点的key数刚好满足定义中的最小值，即刚好“脱贫”，则将节点删除，此时树肯定需要调整，即：
   1. **若删除节点的相邻兄弟节点的key数“富裕”**（节点的key大于定义中的最小值），则父节点的1个key下移与待删除的节点合并，相邻兄弟节点的1个key上移与父节点合并，完成调整；
   2. **若删除节点的相邻兄弟节点的key数刚好“脱贫”**（节点的key刚好满足定义的最小值），则父节点的1个key下移与待删除的节点及相邻兄弟节点，三者进行合并成一个节点，若下移1个key后的父节点的key数刚好“脱贫”或“富裕”，则调整完成，反之，即此时父节点已经陷入“贫穷”，则将父节点看作当前待删除的节点，重复a，b的判断。

如下，是5阶B树删除节点的动态图，

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200527005658)

# B+树

虽然B树这种数据结构，可以极大的减少磁盘的IO次数，但还是有些小瑕疵，如下5阶的B树图，若我需要读取key为“66”与“73”的数据，则此时从根节点“50”开始，“66”大于“50”，找右孩子，即到“60 70 120”的节点，再锁定到“64 66”的节点，找到key为“66”的数据，然后读“73”的数据，再重新从根开始往下寻找key为“73”的数据，如果需要查询的数据量一多，性能就很糟糕。还有一点，就是B树的每个节点都包含key及其value数据，这样的话，每次读取叶子节点的数据时，在经过路径上的非叶子节点也会被读出，但实际上这部分数据我是不需要的，这样又占用了没有必要的内存空间。

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200527005851)

所以，B+树在B树的基础上做了优化，它与B树的差异在于：

1. **有 k 个子节点的节点必然有 k 个key**；
2. **非叶子节点仅具有索引作用**，跟记录有关的信息均存放在叶子节点中。
3. 树的**所有叶子节点构成一个有序链表**，可以按照key排序的次序遍历全部记录。

![img](https://520li.oss-cn-hangzhou.aliyuncs.com/img/20200527010135.jpg)

即，B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

**B+树的优点**在于：

- 由于B+树在内部节点上不包含数据信息，因此在**内存页中能够存放更多的key**。 
    数据存放的更加紧密，具有更好的空间局部性。
    因此访问叶子节点上关联的数据也具有更好的**缓存命中率**。
- B+树的**叶子结点都是相链的**，因此对整棵树的遍历只需要**一次线性遍历叶子结点**即可。
    而且由于数据顺序排列并且相连，所以便于**区间查找和搜索**。
    而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

但是B树也有优点，其优点在于：
由于B树的每一个节点都包含key和value，因此**经常访问的元素可能离根节点更近**，因此访问也更迅速。
