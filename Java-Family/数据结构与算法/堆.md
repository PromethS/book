# 求前N大或前N小

## 求前N大

**使用小顶堆**，堆顶的元素是最最小的，步骤：

- 初始化一个容量为N的小顶堆
- 如果容量未满，则直接加入到堆中
- **如果value大于堆顶，则加入到堆中**，重新调整堆顶
- **如果value小于堆顶，则抛弃**

最后堆中留下来的就是前N大的元素。

## 求前N小

使用大顶堆，堆顶的元素是最最大的，步骤：

- 初始化一个容量为N的大顶堆
- 如果容量未满，则直接加入到堆中
- **如果value小于堆顶，则加入到堆中**，重新调整堆顶
- **如果value大于堆顶，则抛弃**

最后堆中留下来的就是前N小的元素。

## 求中位数

维护一个最大堆和一个最小堆，**最大堆存放比中位数小（或等于）的元素，最小堆存放比中位数大（或等于）的元素**。

每当要插入一个元素时，根据判断条件将它插入最大堆或是最小堆，并更新最大堆和最小堆，**使得最大堆和最小堆中元素的个数之差不超过1**，这样中位数就是最大堆或最小堆的堆顶元素。

当最大堆和最小堆中元素个数不同（个数相差为1）时，元素个数多的那个堆的堆顶元素即为中位数；

如果两者元素个数相同，那么中位数可以是最大堆和最小堆的堆顶元素的值取平均。

insert步骤：

- 1）如果最大堆为空，将元素插入最大堆；

- 2）如果最小堆为空，将元素插入最小堆；

  > **如果最大堆的堆顶大于最小堆的堆顶**，则交换堆顶元素

- 3）**如果元素比最大堆的堆顶元素小且最大堆中元素个数不大于最小堆中元素个数**，将元素插入最大堆；

- 4）**如果如果元素比最大堆的堆顶元素小，但最大堆中元素个数大于最小堆中元素个数，那么先把最大堆的堆顶元素插入最小堆，然后删除最大堆的堆顶元素，最后把元素插入最大堆**；--自平衡的过程

- 5）如果元素比最小堆的堆顶元素大且最小堆中元素个数不大于最大堆中元素个数，将元素插入最小堆；

- 6）**如果如果元素比最小堆的堆顶元素大，但最小堆中元素个数大于最大堆中元素个数，那么先把最小堆的堆顶元素插入最大堆，然后删除最小堆的堆顶元素，最后把元素插入最小堆**；

- 7）如果最大堆中元素个数小于最小堆中元素个数，将元素插入最大堆；否则将元素插入最大堆。